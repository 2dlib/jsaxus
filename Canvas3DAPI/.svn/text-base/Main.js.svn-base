function canvasMain(canvasName)
{
	var scn = new Scene();
	
	// Attach to Canvas3D
	if (scn.createScene(canvasName))
	{
		var cam = new FreeCamera();
		
		// Cubes
		for (var i = 0; i < 2; i++)
		{
			for (var j = 0; j < 2; j++)
			{
				var n = new Cube();
				n.setAngularVel(new Vector(Math.random() * 0.001, 
										   Math.random() * 0.001, 
										   Math.random() * 0.001));
				n.setPosition(new Vector(i * 5, 0, j * 5));
				scn.addObjectToScene(n);			
			}
		}

		// Camera stuff
		cam.setPosition(new Vector(-5.0, 10.0, -5.0));
		cam.setLookAtPoint(new Vector(5.0, 0.0, 5.0));
		scn.addCameraToScene(cam);
		
		// Render Loop
		scn.startScene();
	}
}

function drawCube(gl)
{
    var vs = makeShader(gl, 3, "x-vertex");
	var fs = makeShader(gl, 2, "x-fragment");
	
	sp = gl.createProgram();
	gl.attachShader(sp, vs);
	gl.attachShader(sp, fs);
	gl.linkProgram(sp)
	gl.useProgram(sp);
	
    var va = gl.getAttribLocation(sp, "Vertex"); /* 'vertex' attribute */
    var na = gl.getAttribLocation(sp, "Normal"); /* 'normal' attribute */
    
    var mvUniform = gl.getUniformLocation(sp, "MVMatrix");
    var pmUniform = gl.getUniformLocation(sp, "PMatrix");
    var nmUniform = gl.getUniformLocation(sp, "NMatrix");
	
	// triangle
    if (1) {
        vertices = [ -0.4, 0.4, 0.0,
                     0.0, -0.4, 0.0,
                     0.4, 0.4, 0.0 ];
        normals = [ 0, 0, 1,
                    0, 0, 1,
                    0, 0, 1 ];
        indices = [0, 1, 2];
    }
	
	gl.vertexAttribPointer(va, 3, gl.FLOAT, vertices);
    gl.enableVertexAttribArray(va);
	
	gl.vertexAttribPointer(na, 3, gl.FLOAT, normals);
    gl.enableVertexAttribArray(na);
	
	//var redraw = function()
	{
		gl.enable(gl.DEPTH_TEST);
	
	    var MV = new Matrix();
		MV.setMatrix(new Array(
					 1,    0,    0,    0,
					 0,    0.9,  0.4,  0,
					 0,    -0.4, 0.9,  0,
					 0,    0,    -8,   1));
	    //var P = makePerspective(60, 1, 0.1, 100);
	    var P = makePerspective(60, 1, 0.1, 100);
    
		gl.uniformMatrix(mvUniform, MV.getMatrix());
	    gl.uniformMatrix(pmUniform, P.getMatrix());
	
		gl.drawElements(gl.TRIANGLES, indices.length, indices);
		//gl.drawArrays(gl.TRIANGLES, indices.length, indices);
	
		gl.swapBuffers();
	}
}

// function for testing
function drawTriangle(gl)
{
	if (gl == null)
		return;
	
	var vs = -1; // vertex shader
	var fs = -1; // fragment shader
	var sp = -1; // shader program
	
	vs = makeShader(gl, 1, "x-vertex");
	fs = makeShader(gl, 2, "x-fragment");
    
	sp = gl.createProgram();
	gl.attachShader(sp, vs);
	gl.attachShader(sp, fs);
	gl.linkProgram(sp)
	gl.useProgram(sp);
    
	// myVertex and myPMVmatrix are members of the shader id 1
    var va = gl.getAttribLocation(sp, "myVertex");
    var pmv = gl.getUniformLocation(sp, "myPMVMatrix");
	var obj = gl.getActiveAttrib(sp, va);
    
	gl.uniformMatrix(pmv, [1.0, 0.0, 0.0, 0.0,
                           0.0, 1.0, 0.0, 0.0,
                           0.0, 0.0, 1.0, 0.0,
                           0.0, 0.0, 0.0, 1.0]);
	
    gl.vertexAttribPointer(va, 4, gl.FLOAT, [ -0.4, -0.4, 0.0, 1.0,
                                              0.4, -0.4, 0.0, 1.0,
                                              0.0, 0.4, 0.0, 1.0 ]);
    gl.enableVertexAttribArray(va);
	
    gl.drawArrays(gl.TRIANGLES, 0, 3);
    gl.swapBuffers();
}

// where id is the shader I want and type is either x-fragment or x-vertex
// this function should probably take the shader script and type as parameters
function makeShader(gl, id, type) {
    var script;
	if (id == 1) { // x-vertex
		script = 
		"											\
		attribute vec4 myVertex;					\
		uniform mat4 myPMVMatrix;					\
													\
		void main(void) {							\
			gl_Position = myPMVMatrix * myVertex;	\
		}											\
		";
	}
	else if (id == 2) { // x-fragment
		script = 
		"												\
		void main(void) {								\
			gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);	\
		}												\
		";
	} else if (id == 3) { // x-vertex
		script = 
		"														\
		attribute vec3 Vertex;									\
		attribute vec3 Normal;									\
		attribute vec4 InColor;									\
																\
		uniform mat4 PMatrix;									\
		uniform mat4 MVMatrix;									\
		uniform mat3 NMatrix;									\
																\
		uniform vec4 LightPos;									\
																\
		varying vec4 FragColor;									\
																\
		void main(void) {										\
		    vec4 v = vec4(Vertex, 1.0);							\
		    vec4 vmv = MVMatrix * v;							\
		    gl_Position = PMatrix * vmv;						\
																\
		    vec3 nn = normalize(NMatrix * Normal);				\
		    vec3 lightDir = vec3(normalize(vmv - LightPos));	\
																\
		    float intensity = dot(lightDir, nn);				\
																\
		    vec4 color;											\
																\
		    if (intensity > 0.95)								\
		      color = vec4(1.0,0.5,0.5,1.0);					\
		    else if (intensity > 0.5)							\
		      color = vec4(0.6,0.3,0.3,1.0);					\
		    else if (intensity > 0.25)							\
		      color = vec4(0.4,0.2,0.2,1.0);					\
		    else												\
		      color = vec4(0.2,0.1,0.1,1.0);					\
																\
		    FragColor = color;									\
		}														\
		";
	} else {
		return null;
	}

    var shader;
    if (type == "x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (type == "x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
        return null;
    }

    gl.shaderSource(shader, script);
    gl.compileShader(shader);

    return shader;
}

//
// gluPerspective
//
function makePerspective(fovy, aspect, znear, zfar)
{
    var ymax = znear * Math.tan(fovy * Math.PI / 360.0);
    var ymin = -ymax;
    var xmin = ymin * aspect;
    var xmax = ymax * aspect;

    return makeFrustum(xmin, xmax, ymin, ymax, znear, zfar);
}

//
// glFrustum
//
function makeFrustum(left, right,
                     bottom, top,
                     znear, zfar)
{
    var X = 2*znear/(right-left);
    var Y = 2*znear/(top-bottom);
    var A = (right+left)/(right-left);
    var B = (top+bottom)/(top-bottom);
    var C = -(zfar+znear)/(zfar-znear);
    var D = -2*zfar*znear/(zfar-znear);

    return new Matrix([[X, 0, A, 0],
               [0, Y, B, 0],
               [0, 0, C, D],
               [0, 0, -1, 0]]);
}
